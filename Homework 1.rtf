{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww13140\viewh15340\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Vivianne Dinh\
305329335\
\
Homework 1\
\
2.71 \
a. \
	The problem with the code is that it doesn\'92t account for the fact that bytenum will be implicitly converted to unsigned 	and the function would return an unsigned integer. \
b. \
	int xbyte(packed_t word, int bytenum) \{\
 	   return (word << (3 - bytenum) << 3) >> 24;\
	\}\
\
2.82\
a. (x < y) == (-x > -y)\
	Does not always yield 1. It doesn\'92t yield 1 when x is the min value because -x will overflow and be equivalent to 	x which will always be smaller than y. Therefore, the right side will never be true and the left side will always be true.\
	\
b. ((x + y) << 4) + y - x == 17 * y + 15 * x\
	Always yields 1. (x + y) << 4 and (16 * y + 16 * x) do the same thing. Adding a y and subtracting an x (y - x) to 	the left side makes it equal to the right side (17 * y +15 * x).\
\
c. ~x + ~y + 1 == ~(x + y)\
	Always yields 1. The (-) is like adding 1 to the inverse, so the (~) is the same as taking the negation 	and subtracting 1. By doing the negation to the left side, you get (-x-1)+(-y-1)+1, then get rid of the parenthesis 	and get -x-y-1 which is equal to -(x+y)-1 which equals ~(x+y) since the ~ takes the negation and subtracts 1\
	\
d. (ux - uy) == -(unsigned)(y - x)\
	Always yields 1. The left side is unsigned arithmetic while the right side is signed arithmetic casted to unsigned. 	The bit representations of both sides are the same.\
	\
e. ((x >> 2) << 2) <= x\
	Always yields 1. The result of both the right and the left shift from the left side of the comparison would result in 	the 2 least significant bits being 0 and the rest of the bits will remain the same. If the 2 least significant bits were 	already 0 then it is equal to x and if at least one of the 2 least significant bits was a 1, then it would be less than x.}